import { Handler, Router } from 'express';
import Joi, { SchemaLike } from 'joi';
import {
  ExpressOpenAPI,
  getJoiRequestValidatorPlugin,
  getJoiResponseValidatorPlugin,
  OpenAPISpecification,
} from 'express-joi-openapi';
import { HttpMethod, RequestSegment, ResponseSegment } from 'express-joi-openapi/lib/types';
import { OperationObject } from 'openapi3-ts';

// Utils
import { capitalize } from 'utils/Utils';
import { ErrorCode, errorsMap, getHttpStatusByCode } from 'utils/APIError';

declare type JoiRequestValidationSchema = {
  [segment in RequestSegment]?: SchemaLike;
};

declare type JoiResponseValidationSchema = {
  [statusCode: string]: {
    [segment in ResponseSegment]?: SchemaLike;
  };
};

export const expressOpenApi = new ExpressOpenAPI();

const requestValidatorPlugin = getJoiRequestValidatorPlugin();
const responseValidatorPlugin = getJoiResponseValidatorPlugin({
  skipValidation: true,
});

const validateRequest = expressOpenApi.registerPlugin(requestValidatorPlugin);
const validateResponse = expressOpenApi.registerPlugin(responseValidatorPlugin);

export const generateErrorValidation = (errorCode: ErrorCode, message?: string): JoiResponseValidationSchema => {
  const { code, message: errorMessage } = errorsMap[errorCode];

  return {
    [getHttpStatusByCode(code)]: {
      body: Joi.object({
        error: {
          code: Joi.string().valid(code).required(),
          message: Joi.string()
            .valid(message || errorMessage)
            .required(),
        },
        meta: Joi.object({
          timer: Joi.number(),
          timerAvg: Joi.number(),
        }).required(),
      }),
    },
  };
};

export const generateResponseValidation = (
  schema: SchemaLike,
  { authorization = true, statusCode = 200 }: { authorization?: boolean; statusCode?: number | string } = {}
): JoiResponseValidationSchema => {
  return {
    [statusCode]: {
      body: Joi.object({
        data: schema,
        meta: Joi.object({
          timer: Joi.number(),
          timerAvg: Joi.number(),
        }).required(),
      }),
    },
    ...(authorization ? generateErrorValidation(ErrorCode.UNAUTHORIZED) : null),
  };
};

export const validate = ({
  request,
  response,
}: {
  request?: JoiRequestValidationSchema;
  response?: JoiResponseValidationSchema;
}): Handler[] => {
  const resultMiddlewareArray: Handler[] = [];

  if (request) {
    resultMiddlewareArray.push(validateRequest(request));
  }

  if (response) {
    resultMiddlewareArray.push(validateResponse(response));
  }

  return resultMiddlewareArray;
};

export const wsSpecificationPaths: {
  path: string;
  pathItem: { [method in HttpMethod]?: OperationObject };
}[] = [];

export const generateSpecification = (router: Router): OpenAPISpecification => {
  const autoGeneratedSpecification = expressOpenApi.populateSpecification(router);
  const resultSpecification = new OpenAPISpecification()

    // Info
    .setInfo({
      title: 'Softenq',
      description: 'Documentation for API timetracker\n\n<a href="/docs/swagger.json" target="_blank">Open schema</a>',
      version: '0.0.1',
    })

    // Servers
    .addServer({
      url: 'http://127.0.0.1:3000',
      description: 'Local',
    })

    // Security schemas
    .setComponent('securitySchemes', 'BearerAuth', {
      type: 'http',
      scheme: 'bearer',
    });

  Object.entries(autoGeneratedSpecification.paths).forEach(
    ([path, pathObj]: [string, { [method in HttpMethod]?: OperationObject }]) => {
      const splitPath = path.split('/').slice(1);
      const pathItem: { [method in HttpMethod]?: OperationObject } = {};
      const tag = capitalize(splitPath[0]);

      Object.entries(pathObj).forEach(([method, pathData]: [HttpMethod, OperationObject]) => {
        pathItem[method] = {
          ...pathData,
          tags: [tag],
          security: !['/auth/login'].includes(path) ? [{ BearerAuth: [] }] : [],
        };
      });

      resultSpecification.setPathItem(path, pathItem);
    }
  );

  wsSpecificationPaths.forEach(({ path, pathItem }) => {
    if (resultSpecification.getPathItem(path)) {
      Object.entries(pathItem).forEach(([method, operationObject]) => {
        resultSpecification.setPathItemOperation(path, method as HttpMethod, operationObject!);
      });
    } else {
      resultSpecification.setPathItem(path, pathItem);
    }
  });

  return resultSpecification;
};
